main: DO SEMICOLON ELSEIF
##
## Ends in an error in state: 113.
##
## stmt -> DO stmts . END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## DO stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `end` to terminate `do` block

main: DO UNTIL
##
## Ends in an error in state: 111.
##
## stmt -> DO . stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## DO
##

Expected statement within `do` block

main: FOR IDENT COMMA IDENT WHILE
##
## Ends in an error in state: 143.
##
## stmt -> FOR sep_list1(COMMA,var) . IN sep_list1(COMMA,expr) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR sep_list1(COMMA,var)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production sep_list1(COMMA,var) -> var
## In state 142, spurious reduction of production sep_list1(COMMA,var) -> var COMMA sep_list1(COMMA,var)
##

Expected `in` after for loop variables

main: FOR IDENT EQUALS TRUE COMMA TRUE COMMA TRUE WHILE
##
## Ends in an error in state: 108.
##
## expr -> expr . AND expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . OR expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . ADD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . SUB expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . MUL expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . DIV expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . MOD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . CONCAT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . EQ expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . NE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . LT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . LE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . GT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . GE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## option(__anonymous_1) -> COMMA expr . [ DO ]
##
## The known suffix of the stack is as follows:
## COMMA expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `do` after for loop initialisation
We should have something of the form
 - for i = 1, 10, 1 do ... end

main: FOR IDENT EQUALS TRUE COMMA TRUE COMMA WHILE
##
## Ends in an error in state: 107.
##
## option(__anonymous_1) -> COMMA . expr [ DO ]
##
## The known suffix of the stack is as follows:
## COMMA
##

Expected expression for for loop step

main: FOR IDENT EQUALS TRUE COMMA TRUE DO SEMICOLON ELSEIF
##
## Ends in an error in state: 138.
##
## stmt -> FOR var EQUALS expr COMMA expr option(__anonymous_1) DO stmts . END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR var EQUALS expr COMMA expr option(__anonymous_1) DO stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `end` in order to close for loop

main: FOR IDENT EQUALS TRUE COMMA TRUE DO UNTIL
##
## Ends in an error in state: 110.
##
## stmt -> FOR var EQUALS expr COMMA expr option(__anonymous_1) DO . stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR var EQUALS expr COMMA expr option(__anonymous_1) DO
##

Expected `end` in order to close for loop

main: FOR IDENT EQUALS TRUE COMMA TRUE WHILE
##
## Ends in an error in state: 106.
##
## expr -> expr . AND expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . OR expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . ADD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . SUB expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . MUL expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . DIV expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . MOD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . CONCAT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . EQ expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . NE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . LT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . LE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . GT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## expr -> expr . GE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT COMMA AND ADD ]
## stmt -> FOR var EQUALS expr COMMA expr . option(__anonymous_1) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR var EQUALS expr COMMA expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `do` to finish for loop initialisation.
We expect something of the form
 - for i = 1, 10 do end or
 - for i = 1, 10, 1 do end

main: FOR IDENT EQUALS TRUE COMMA WHILE
##
## Ends in an error in state: 105.
##
## stmt -> FOR var EQUALS expr COMMA . expr option(__anonymous_1) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR var EQUALS expr COMMA
##

Expected expression for for loop limit

main: FOR IDENT EQUALS TRUE WHILE
##
## Ends in an error in state: 104.
##
## expr -> expr . AND expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . OR expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . ADD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . SUB expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . MUL expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . DIV expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . MOD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . CONCAT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . EQ expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . NE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . LT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . LE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . GT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## expr -> expr . GE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA AND ADD ]
## stmt -> FOR var EQUALS expr . COMMA expr option(__anonymous_1) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR var EQUALS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected comma after for loop start

main: FOR IDENT EQUALS WHILE
##
## Ends in an error in state: 103.
##
## stmt -> FOR var EQUALS . expr COMMA expr option(__anonymous_1) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR var EQUALS
##

Expected for loop start and limit.
You should have something like
 - for i = 1, 10 do ... end

main: FOR IDENT IN TRUE DO SEMICOLON ELSEIF
##
## Ends in an error in state: 147.
##
## stmt -> FOR sep_list1(COMMA,var) IN sep_list1(COMMA,expr) DO stmts . END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR sep_list1(COMMA,var) IN sep_list1(COMMA,expr) DO stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `end` to close for loop.

main: FOR IDENT IN TRUE DO UNTIL
##
## Ends in an error in state: 146.
##
## stmt -> FOR sep_list1(COMMA,var) IN sep_list1(COMMA,expr) DO . stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR sep_list1(COMMA,var) IN sep_list1(COMMA,expr) DO
##

Expected `end` in order to close for loop

main: FOR IDENT IN TRUE WHILE
##
## Ends in an error in state: 145.
##
## stmt -> FOR sep_list1(COMMA,var) IN sep_list1(COMMA,expr) . DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR sep_list1(COMMA,var) IN sep_list1(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
## In state 74, spurious reduction of production sep_list1(COMMA,expr) -> expr
##

Expected `end` after for loop initialiser

main: FOR IDENT IN WHILE
##
## Ends in an error in state: 144.
##
## stmt -> FOR sep_list1(COMMA,var) IN . sep_list1(COMMA,expr) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR sep_list1(COMMA,var) IN
##

Expected generator expression in for loop

main: FOR IDENT WHILE
##
## Ends in an error in state: 102.
##
## sep_list1(COMMA,var) -> var . [ IN ]
## sep_list1(COMMA,var) -> var . COMMA sep_list1(COMMA,var) [ IN ]
## stmt -> FOR var . EQUALS expr COMMA expr option(__anonymous_1) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR var
##

Expected `=` or `in` after `for` loop variables

main: FOR WHILE
##
## Ends in an error in state: 101.
##
## stmt -> FOR . var EQUALS expr COMMA expr option(__anonymous_1) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
## stmt -> FOR . sep_list1(COMMA,var) IN sep_list1(COMMA,expr) DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FOR
##

Expected loop variabliables within `for` loop

main: FUNCTION IDENT COLON WHILE
##
## Ends in an error in state: 98.
##
## function_name -> function_name COLON . IDENT [ OPAREN DOT COLON ]
##
## The known suffix of the stack is as follows:
## function_name COLON
##

Expected method name after `:`.

main: FUNCTION IDENT DOT WHILE
##
## Ends in an error in state: 96.
##
## function_name -> function_name DOT . IDENT [ OPAREN DOT COLON ]
##
## The known suffix of the stack is as follows:
## function_name DOT
##

Expected function name after `.`.

main: FUNCTION IDENT OPAREN CPAREN SEMICOLON ELSEIF
##
## Ends in an error in state: 149.
##
## stmt -> FUNCTION function_name args stmts . END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FUNCTION function_name args stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `end` to terminate function definition.

main: FUNCTION IDENT OPAREN CPAREN UNTIL
##
## Ends in an error in state: 100.
##
## stmt -> FUNCTION function_name args . stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FUNCTION function_name args
##

Expected statement within function body.

main: FUNCTION IDENT WHILE
##
## Ends in an error in state: 95.
##
## function_name -> function_name . DOT IDENT [ OPAREN DOT COLON ]
## function_name -> function_name . COLON IDENT [ OPAREN DOT COLON ]
## stmt -> FUNCTION function_name . args stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FUNCTION function_name
##

Expected `(` to start this function's argument list.

main: FUNCTION WHILE
##
## Ends in an error in state: 93.
##
## stmt -> FUNCTION . function_name args stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

Expected function name in function definition.
You cannot have an anonymous functions at the top level!

main: IDENT COLON IDENT WHILE
##
## Ends in an error in state: 80.
##
## call -> simple_expr COLON IDENT . call_args [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## simple_expr COLON IDENT
##

Expected argument in self-call.

main: IDENT COLON WHILE
##
## Ends in an error in state: 79.
##
## call -> simple_expr COLON . IDENT call_args [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## simple_expr COLON
##

Expected method name in self-call.

main: IDENT COMMA WHILE
##
## Ends in an error in state: 121.
##
## sep_list1(COMMA,name) -> name COMMA . sep_list1(COMMA,name) [ EQUALS ]
##
## The known suffix of the stack is as follows:
## name COMMA
##

Expected another variable in assignment list.

main: IDENT DOT WHILE
##
## Ends in an error in state: 77.
##
## name -> simple_expr DOT . IDENT [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQUALS EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## simple_expr DOT
##

Expected table key after `.`.

main: IDENT EQUALS WHILE
##
## Ends in an error in state: 118.
##
## stmt -> sep_list1(COMMA,name) EQUALS . sep_list1(COMMA,expr) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## sep_list1(COMMA,name) EQUALS
##

Expected expressions on right hand side of an assignment.

main: IDENT OPAREN TRUE BREAK
##
## Ends in an error in state: 72.
##
## call_args -> OPAREN sep_list0(COMMA,expr) . CPAREN [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## OPAREN sep_list0(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
## In state 74, spurious reduction of production sep_list1(COMMA,expr) -> expr
## In state 71, spurious reduction of production sep_list0(COMMA,expr) -> sep_list1(COMMA,expr)
##

Expecting `)` to close opening `(`.

main: IDENT OPAREN WHILE
##
## Ends in an error in state: 70.
##
## call_args -> OPAREN . sep_list0(COMMA,expr) CPAREN [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## OPAREN
##

Expected expression after `(`.

main: IDENT OSQUARE TRUE WHILE
##
## Ends in an error in state: 40.
##
## expr -> expr . AND expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . OR expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . ADD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . SUB expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . MUL expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . DIV expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . MOD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . CONCAT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . EQ expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . NE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . LT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . LE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . GT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . GE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## name -> simple_expr OSQUARE expr . CSQUARE [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQUALS EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## simple_expr OSQUARE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `]` to close table index.

main: IDENT OSQUARE WHILE
##
## Ends in an error in state: 33.
##
## name -> simple_expr OSQUARE . expr CSQUARE [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQUALS EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## simple_expr OSQUARE
##

Expected expression within table index.

main: IDENT STRING TRUE
##
## Ends in an error in state: 130.
##
## simple_expr -> call . [ STRING OSQUARE OPAREN OBRACE DOT COLON ]
## stmt -> call . [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## call
##

Unexpected token after function call

main: IDENT WHILE
##
## Ends in an error in state: 120.
##
## sep_list1(COMMA,name) -> name . [ EQUALS ]
## sep_list1(COMMA,name) -> name . COMMA sep_list1(COMMA,name) [ EQUALS ]
## simple_expr -> name . [ STRING OSQUARE OPAREN OBRACE DOT COLON ]
##
## The known suffix of the stack is as follows:
## name
##

Unexpected token after variable.

main: IF TRUE THEN BREAK UNTIL
##
## Ends in an error in state: 124.
##
## stmt -> if_clause(IF) . list(if_clause(ELSEIF)) option(__anonymous_0) END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## if_clause(IF)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
## In state 151, spurious reduction of production if_clause(IF) -> IF expr THEN stmts
##

Expected `end` to terminate this if block.

main: IF TRUE THEN ELSE SEMICOLON UNTIL
##
## Ends in an error in state: 134.
##
## stmt -> if_clause(IF) list(if_clause(ELSEIF)) option(__anonymous_0) . END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## if_clause(IF) list(if_clause(ELSEIF)) option(__anonymous_0)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
## In state 133, spurious reduction of production option(__anonymous_0) -> ELSE stmts
##

Expected `end` to terminate this if block.

main: IF TRUE THEN ELSE UNTIL
##
## Ends in an error in state: 132.
##
## option(__anonymous_0) -> ELSE . stmts [ END ]
##
## The known suffix of the stack is as follows:
## ELSE
##

Expected statement within `else` body.

main: IF TRUE THEN ELSEIF TRUE THEN BREAK UNTIL
##
## Ends in an error in state: 136.
##
## list(if_clause(ELSEIF)) -> if_clause(ELSEIF) . list(if_clause(ELSEIF)) [ END ELSE ]
##
## The known suffix of the stack is as follows:
## if_clause(ELSEIF)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
## In state 128, spurious reduction of production if_clause(ELSEIF) -> ELSEIF expr THEN stmts
##

Expected `end` to terminate this if block.

main: IF TRUE THEN ELSEIF TRUE THEN UNTIL
##
## Ends in an error in state: 127.
##
## if_clause(ELSEIF) -> ELSEIF expr THEN . stmts [ END ELSEIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr THEN
##

Expected statement within `elseif` body.


main: IF TRUE THEN ELSEIF TRUE WHILE
##
## Ends in an error in state: 126.
##
## expr -> expr . AND expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . OR expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . ADD expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . SUB expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . MUL expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . DIV expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . MOD expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . CONCAT expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . EQ expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . NE expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . LT expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . LE expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . GT expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . GE expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## if_clause(ELSEIF) -> ELSEIF expr . THEN stmts [ END ELSEIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSEIF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `then` within `elseif` condition.

main: IF TRUE THEN ELSEIF WHILE
##
## Ends in an error in state: 125.
##
## if_clause(ELSEIF) -> ELSEIF . expr THEN stmts [ END ELSEIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSEIF
##

Expected condition after `elseif`.

main: IF TRUE THEN UNTIL
##
## Ends in an error in state: 92.
##
## if_clause(IF) -> IF expr THEN . stmts [ END ELSEIF ELSE ]
##
## The known suffix of the stack is as follows:
## IF expr THEN
##

Expected `end` to close `if` block

main: IF TRUE WHILE
##
## Ends in an error in state: 91.
##
## expr -> expr . AND expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . OR expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . ADD expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . SUB expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . MUL expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . DIV expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . MOD expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . CONCAT expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . EQ expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . NE expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . LT expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . LE expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . GT expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## expr -> expr . GE expr [ THEN SUB OR NE MUL MOD LT LE GT GE EQ DIV CONCAT AND ADD ]
## if_clause(IF) -> IF expr . THEN stmts [ END ELSEIF ELSE ]
##
## The known suffix of the stack is as follows:
## IF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `then` after `if` condition.

main: IF WHILE
##
## Ends in an error in state: 90.
##
## if_clause(IF) -> IF . expr THEN stmts [ END ELSEIF ELSE ]
##
## The known suffix of the stack is as follows:
## IF
##

Expected `condition` after `if`

main: LOCAL FUNCTION IDENT OPAREN CPAREN SEMICOLON ELSEIF
##
## Ends in an error in state: 152.
##
## stmt -> LOCAL FUNCTION var args stmts . END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## LOCAL FUNCTION var args stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `end` to close function definition.

main: LOCAL FUNCTION IDENT OPAREN CPAREN UNTIL
##
## Ends in an error in state: 89.
##
## stmt -> LOCAL FUNCTION var args . stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## LOCAL FUNCTION var args
##

Expected statement within function definition.

main: LOCAL FUNCTION IDENT WHILE
##
## Ends in an error in state: 88.
##
## stmt -> LOCAL FUNCTION var . args stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## LOCAL FUNCTION var
##

Expected `(` to start this function's argument list.

main: LOCAL FUNCTION WHILE
##
## Ends in an error in state: 87.
##
## stmt -> LOCAL FUNCTION . var args stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## LOCAL FUNCTION
##

Expected local function name.

main: LOCAL IDENT COMMA WHILE
##
## Ends in an error in state: 140.
##
## sep_list1(COMMA,var) -> var COMMA . sep_list1(COMMA,var) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IN IF IDENT FUNCTION FOR EQUALS EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## var COMMA
##

Expected another identifier in function's argument list.

main: LOCAL IDENT EQUALS WHILE
##
## Ends in an error in state: 155.
##
## option(__anonymous_2) -> EQUALS . sep_list1(COMMA,expr) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## EQUALS
##

Expected an expression on the right hand side of a `local` declaration.

main: LOCAL IDENT IN
##
## Ends in an error in state: 154.
##
## stmt -> LOCAL sep_list1(COMMA,var) . option(__anonymous_2) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## LOCAL sep_list1(COMMA,var)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production sep_list1(COMMA,var) -> var
##

Expected statement or `=` after a `local` declaration

main: LOCAL IDENT TRUE
##
## Ends in an error in state: 141.
##
## sep_list1(COMMA,var) -> var . [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IN IF IDENT FUNCTION FOR EQUALS EOF END ELSEIF ELSE DO BREAK ]
## sep_list1(COMMA,var) -> var . COMMA sep_list1(COMMA,var) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IN IF IDENT FUNCTION FOR EQUALS EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## var
##

Unexpected token after identifier.

main: LOCAL WHILE
##
## Ends in an error in state: 86.
##
## stmt -> LOCAL . sep_list1(COMMA,var) option(__anonymous_2) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
## stmt -> LOCAL . FUNCTION var args stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## LOCAL
##

Expected identifier after `local`.

main: OPAREN TRUE CPAREN CBRACE
##
## Ends in an error in state: 116.
##
## call -> simple_expr . call_args [ WHILE UNTIL STRING SEMICOLON RETURN REPEAT OSQUARE OPAREN OBRACE LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DOT DO COLON BREAK ]
## call -> simple_expr . COLON IDENT call_args [ WHILE UNTIL STRING SEMICOLON RETURN REPEAT OSQUARE OPAREN OBRACE LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DOT DO COLON BREAK ]
## name -> simple_expr . DOT IDENT [ STRING OSQUARE OPAREN OBRACE EQUALS DOT COMMA COLON ]
## name -> simple_expr . OSQUARE expr CSQUARE [ STRING OSQUARE OPAREN OBRACE EQUALS DOT COMMA COLON ]
##
## The known suffix of the stack is as follows:
## simple_expr
##

We've just finished parsing a simple expression.

main: OPAREN TRUE WHILE
##
## Ends in an error in state: 180.
##
## expr -> expr . AND expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . OR expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . ADD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . SUB expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . MUL expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . DIV expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . MOD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . CONCAT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . EQ expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . NE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . LT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . LE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . GT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## expr -> expr . GE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CPAREN CONCAT AND ADD ]
## simple_expr -> OPAREN expr . CPAREN [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## OPAREN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `)` to close opening parenthesis.

main: OPAREN WHILE
##
## Ends in an error in state: 5.
##
## simple_expr -> OPAREN . expr CPAREN [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## OPAREN
##

Expected expression after `(`.

main: REPEAT SEMICOLON EOF
##
## Ends in an error in state: 158.
##
## stmt -> REPEAT stmts . UNTIL expr [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## REPEAT stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `until` to terminate repeat loop.

main: REPEAT TRUE
##
## Ends in an error in state: 85.
##
## stmt -> REPEAT . stmts UNTIL expr [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## REPEAT
##

Expected `until` to termiante `repeat` block

main: REPEAT UNTIL TRUE THEN
##
## Ends in an error in state: 160.
##
## expr -> expr . AND expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . OR expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . ADD expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . SUB expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . MUL expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . DIV expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . MOD expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . CONCAT expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . EQ expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . NE expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . LT expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . LE expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . GT expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## expr -> expr . GE expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CONCAT BREAK AND ADD ]
## stmt -> REPEAT stmts UNTIL expr . [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## REPEAT stmts UNTIL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

This is unexpected after a `repeat` block.

main: REPEAT UNTIL WHILE
##
## Ends in an error in state: 159.
##
## stmt -> REPEAT stmts UNTIL . expr [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## REPEAT stmts UNTIL
##

Expected expression for `repeat` condition.

main: RETURN FUNCTION OPAREN CPAREN SEMICOLON ELSEIF
##
## Ends in an error in state: 161.
##
## atom -> FUNCTION args stmts . END [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## FUNCTION args stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `end` to terminate function body.

main: RETURN FUNCTION OPAREN CPAREN UNTIL
##
## Ends in an error in state: 24.
##
## atom -> FUNCTION args . stmts END [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## FUNCTION args
##

Expected `end` to close function expression.

main: RETURN FUNCTION OPAREN IDENT COMMA WHILE
##
## Ends in an error in state: 22.
##
## sep_list1(COMMA,arg) -> arg COMMA . sep_list1(COMMA,arg) [ CPAREN ]
##
## The known suffix of the stack is as follows:
## arg COMMA
##

Expected another function argument within argument list.

main: RETURN FUNCTION OPAREN IDENT WHILE
##
## Ends in an error in state: 21.
##
## sep_list1(COMMA,arg) -> arg . [ CPAREN ]
## sep_list1(COMMA,arg) -> arg . COMMA sep_list1(COMMA,arg) [ CPAREN ]
##
## The known suffix of the stack is as follows:
## arg
##

Expected another argument or `)` within argument list.

main: RETURN FUNCTION OPAREN WHILE
##
## Ends in an error in state: 15.
##
## args -> OPAREN . sep_list0(COMMA,arg) CPAREN [ WHILE SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR END DO BREAK ]
##
## The known suffix of the stack is as follows:
## OPAREN
##

Expected another argument or `)` within argument list.

main: RETURN FUNCTION WHILE
##
## Ends in an error in state: 14.
##
## atom -> FUNCTION . args stmts END [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

Expected `(` to start function's argument list.

main: RETURN IDENT TRUE
##
## Ends in an error in state: 31.
##
## atom -> simple_expr . [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
## call -> simple_expr . call_args [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
## call -> simple_expr . COLON IDENT call_args [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
## name -> simple_expr . DOT IDENT [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
## name -> simple_expr . OSQUARE expr CSQUARE [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## simple_expr
##

This is unexpected after a a simple expression.

main: RETURN LEN WHILE
##
## Ends in an error in state: 11.
##
## expr_pow -> LEN . expr_pow [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## LEN
##

Expected an expression after `#`.

main: RETURN NOT WHILE
##
## Ends in an error in state: 9.
##
## expr_pow -> NOT . expr_pow [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## NOT
##

Expected an expression after `not`

main: RETURN OBRACE IDENT EQUALS TRUE WHILE
##
## Ends in an error in state: 171.
##
## expr -> expr . AND expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . OR expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . ADD expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . SUB expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . MUL expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . DIV expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . MOD expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . CONCAT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . EQ expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . NE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . LT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . LE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . GT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . GE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## table_entry -> IDENT EQUALS expr . [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## IDENT EQUALS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `}` to close table.

main: RETURN OBRACE IDENT EQUALS WHILE
##
## Ends in an error in state: 170.
##
## table_entry -> IDENT EQUALS . expr [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## IDENT EQUALS
##

Expected expression after `=` in table entry.

main: RETURN OBRACE OSQUARE TRUE CSQUARE EQUALS TRUE WHILE
##
## Ends in an error in state: 168.
##
## expr -> expr . AND expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . OR expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . ADD expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . SUB expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . MUL expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . DIV expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . MOD expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . CONCAT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . EQ expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . NE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . LT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . LE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . GT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . GE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## table_entry -> OSQUARE expr CSQUARE EQUALS expr . [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## OSQUARE expr CSQUARE EQUALS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `,` or `}` after table entry.

main: RETURN OBRACE OSQUARE TRUE CSQUARE EQUALS WHILE
##
## Ends in an error in state: 167.
##
## table_entry -> OSQUARE expr CSQUARE EQUALS . expr [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## OSQUARE expr CSQUARE EQUALS
##

Expected expression after `=` in table entry.

main: RETURN OBRACE OSQUARE TRUE CSQUARE WHILE
##
## Ends in an error in state: 166.
##
## table_entry -> OSQUARE expr CSQUARE . EQUALS expr [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## OSQUARE expr CSQUARE
##

Expected `=` after table key.

main: RETURN OBRACE OSQUARE TRUE WHILE
##
## Ends in an error in state: 165.
##
## expr -> expr . AND expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . OR expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . ADD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . SUB expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . MUL expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . DIV expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . MOD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . CONCAT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . EQ expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . NE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . LT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . LE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . GT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## expr -> expr . GE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DIV CSQUARE CONCAT AND ADD ]
## table_entry -> OSQUARE expr . CSQUARE EQUALS expr [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## OSQUARE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `]` to close `[` in table key.

main: RETURN OBRACE OSQUARE WHILE
##
## Ends in an error in state: 7.
##
## table_entry -> OSQUARE . expr CSQUARE EQUALS expr [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## OSQUARE
##

Expected expression after opening table key.

main: RETURN OBRACE TRUE SEMICOLON WHILE
##
## Ends in an error in state: 175.
##
## table_body -> table_entry table_sep . table_body [ CBRACE ]
##
## The known suffix of the stack is as follows:
## table_entry table_sep
##

Expected `}` or table entry.

main: RETURN OBRACE TRUE WHILE
##
## Ends in an error in state: 177.
##
## expr -> expr . AND expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . OR expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . ADD expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . SUB expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . MUL expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . DIV expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . MOD expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . CONCAT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . EQ expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . NE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . LT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . LE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . GT expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## expr -> expr . GE expr [ SUB SEMICOLON OR NE MUL MOD LT LE GT GE EQ DIV CONCAT COMMA CBRACE AND ADD ]
## table_entry -> expr . [ SEMICOLON COMMA CBRACE ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

This is unexpected after an expression.

main: RETURN OBRACE WHILE
##
## Ends in an error in state: 6.
##
## table -> OBRACE . table_body CBRACE [ WHILE UNTIL THEN SUB STRING SEMICOLON RETURN REPEAT POW OSQUARE OR OPAREN OBRACE NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV CSQUARE CPAREN CONCAT COMMA COLON CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## OBRACE
##

Expected some table entry:
  - expr
  - key = expr
  - [key] = expr

main: RETURN SUB WHILE
##
## Ends in an error in state: 3.
##
## expr_pow -> SUB . expr_pow [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## SUB
##

Expected expression after operator

main: RETURN THEN
##
## Ends in an error in state: 26.
##
## stmt -> RETURN . sep_list0(COMMA,expr) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## RETURN
##

Expected an expression or end of block after `return`.

main: RETURN TRUE ADD WHILE
##
## Ends in an error in state: 63.
##
## expr -> expr ADD . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr ADD
##

Expected expression after operator

main: RETURN TRUE AND WHILE
##
## Ends in an error in state: 47.
##
## expr -> expr AND . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr AND
##

Expected expression after operator

main: RETURN TRUE COMMA WHILE
##
## Ends in an error in state: 75.
##
## sep_list1(COMMA,expr) -> expr COMMA . sep_list1(COMMA,expr) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO CPAREN BREAK ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

# TODO: We should improve this to disambiguate between returns and calls
Expected expression after comma

main: RETURN TRUE CONCAT WHILE
##
## Ends in an error in state: 59.
##
## expr -> expr CONCAT . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr CONCAT
##

Expected expression after operator

main: RETURN TRUE DIV WHILE
##
## Ends in an error in state: 67.
##
## expr -> expr DIV . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr DIV
##

Expected expression after operator

main: RETURN TRUE EQ WHILE
##
## Ends in an error in state: 57.
##
## expr -> expr EQ . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr EQ
##

Expected expression after operator

main: RETURN TRUE GE WHILE
##
## Ends in an error in state: 55.
##
## expr -> expr GE . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr GE
##

Expected expression after operator

main: RETURN TRUE GT WHILE
##
## Ends in an error in state: 53.
##
## expr -> expr GT . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr GT
##

Expected expression after operator

main: RETURN TRUE LE WHILE
##
## Ends in an error in state: 51.
##
## expr -> expr LE . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr LE
##

Expected expression after operator

main: RETURN TRUE LT WHILE
##
## Ends in an error in state: 49.
##
## expr -> expr LT . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr LT
##

Expected expression after operator

main: RETURN TRUE MOD WHILE
##
## Ends in an error in state: 65.
##
## expr -> expr MOD . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr MOD
##

Expected expression after operator

main: RETURN TRUE MUL WHILE
##
## Ends in an error in state: 61.
##
## expr -> expr MUL . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr MUL
##

Expected expression after operator

main: RETURN TRUE NE WHILE
##
## Ends in an error in state: 45.
##
## expr -> expr NE . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr NE
##

Expected expression after operator

main: RETURN TRUE OR WHILE
##
## Ends in an error in state: 43.
##
## expr -> expr OR . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr OR
##

Expected expression after operator

main: RETURN TRUE POW WHILE
##
## Ends in an error in state: 36.
##
## expr_pow -> expr_pow POW . expr_pow [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr_pow POW
##

Expected expression after operator

main: RETURN TRUE SUB WHILE
##
## Ends in an error in state: 41.
##
## expr -> expr SUB . expr [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr SUB
##

Expected expression after operator

main: RETURN TRUE THEN
##
## Ends in an error in state: 74.
##
## expr -> expr . AND expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . OR expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . ADD expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . SUB expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . MUL expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . DIV expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . MOD expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . CONCAT expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . EQ expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . NE expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . LT expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . LE expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . GT expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## expr -> expr . GE expr [ WHILE UNTIL SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CPAREN CONCAT COMMA BREAK AND ADD ]
## sep_list1(COMMA,expr) -> expr . [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO CPAREN BREAK ]
## sep_list1(COMMA,expr) -> expr . COMMA sep_list1(COMMA,expr) [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO CPAREN BREAK ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Unexpected symbol after expression.

main: RETURN TRUE TRUE
##
## Ends in an error in state: 35.
##
## expr -> expr_pow . [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
## expr_pow -> expr_pow . POW expr_pow [ WHILE UNTIL THEN SUB SEMICOLON RETURN REPEAT POW OR OPAREN NE MUL MOD LT LOCAL LE IF IDENT GT GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV CSQUARE CPAREN CONCAT COMMA CBRACE BREAK AND ADD ]
##
## The known suffix of the stack is as follows:
## expr_pow
##

Unexpected symbol after expression.

main: SEMICOLON TRUE
##
## Ends in an error in state: 115.
##
## list(stmt) -> stmt . list(stmt) [ UNTIL EOF END ELSEIF ELSE ]
##
## The known suffix of the stack is as follows:
## stmt
##

Expected another statement or end of block.

main: SEMICOLON UNTIL
##
## Ends in an error in state: 187.
##
## main -> stmts . EOF [ # ]
##
## The known suffix of the stack is as follows:
## stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected another statement or end of file.

main: UNTIL
##
## Ends in an error in state: 0.
##
## main' -> . main [ # ]
##
## The known suffix of the stack is as follows:
##
##

Expected the end of file.

main: WHILE TRUE DO SEMICOLON ELSEIF
##
## Ends in an error in state: 185.
##
## stmt -> WHILE expr DO stmts . END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO stmts
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 115, spurious reduction of production list(stmt) ->
## In state 123, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 129, spurious reduction of production stmts -> list(stmt)
##

Expected `end` to terminate while loop.


main: WHILE TRUE DO UNTIL
##
## Ends in an error in state: 184.
##
## stmt -> WHILE expr DO . stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO
##

Expected `end` to close `while` loop

main: WHILE TRUE WHILE
##
## Ends in an error in state: 183.
##
## expr -> expr . AND expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . OR expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . ADD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . SUB expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . MUL expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . DIV expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . MOD expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . CONCAT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . EQ expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . NE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . LT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . LE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . GT expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## expr -> expr . GE expr [ SUB OR NE MUL MOD LT LE GT GE EQ DO DIV CONCAT AND ADD ]
## stmt -> WHILE expr . DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 35, spurious reduction of production expr -> expr_pow
##

Expected `do` after `while` loop condition.

main: WHILE WHILE
##
## Ends in an error in state: 1.
##
## stmt -> WHILE . expr DO stmts END [ WHILE UNTIL SEMICOLON RETURN REPEAT OPAREN LOCAL IF IDENT FUNCTION FOR EOF END ELSEIF ELSE DO BREAK ]
##
## The known suffix of the stack is as follows:
## WHILE
##

Expected condition for `while` loop
